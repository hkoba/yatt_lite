=encoding utf-8

=head1 NAME

YATT::Lite::LRXML::Syntax - Loose but Recursive XML (LRXML) format.

=for code perl

=head1 SYNOPSIS

  require YATT::Lite::LRXML;
  my $container = YATT::Lite::LRXML->load_from(string => <<'END');
  <!yatt:args x y>
  <h2>&yatt:x;</h2>
  &yatt:y;

  <!yatt:widget foo id x>
  <div id="&yatt:id;">
    &yatt:x;
  </div>
  END

=head1 DESCRIPTION

Loose but Recursive XML (B<LRXML>), which I'm defining here,
is a XML-like template format. LRXML is first used in
my template engine L<YATT> and then extended in
my former template engine L<YATT::Lite>.

=head2 WIP

=over 4

=item * lrxml-boundary is designed to carry meta-info of template.

=back

=head1 FORMAT SPECIFICATION

=head2 LRXML Syntax definition in ABNF (with negative-match)
X<syntax> X<BNF>

LRXML format consists of 3 layers of syntax definition
which are L<"LRXML multi-part container"|/LRXML-multi-part-container>
(or simply I<container>),
L<"LRXML template"|/LRXML-template> (I<template>)
and L<"LRXML entity reference"|/LRXML-entity-reference> (I<entref>)
A container can carry multiple parts.
Parts can be templates and other types of text payload.
At LRXML format level, type of each part is not defined.
It must be defined by LRXML user.

In this document, I (roughly) use L<ABNF|https://tools.ietf.org/html/rfc5234>,
with some modifications/extensions.

=over 4

=item C<[..]> means a character set, like regexp in perl5.

=item The operator "C<?>" is equivalent of C<*1> and indicates I<optional element>.

=item The operator "C< ¬ >" preceding an element indicates I<negative-match>.

If an element is written like:

   ¬ elem

then this pattern matches I<longest> possible character sequence
which do not match C<elem>. This operator helps defining customizable namespace.

=item Rule can take parameter.

If left-hand-side of a rule definition consists of two or more words,
it is a parametric rule. Parametric rule is used like C<< <rule Param> >>.

   group C          =  *term C

   ...other rule... =   <group ")">


=back

=head3 Customizable namespace qualifier

In LRXML, every top-level constructs are marked by I<namespace qualifier>
(or simply I<namespace>).
Namespace can be customized to arbitrary set of words.
For simplicity, in this document, I put a "sample" definition of
customizable namespace rule C<CNS> like:

  CNS             = ("yatt")

But every implementation of LRXML parser should allow overriding this rule like
following instead:

  CNS             = ("yatt" / "js" / "perl")

=head3 BNF of LRXML multi-part container
X<LRXML-multi-part-container>

  lrxml-container = ?(lrxml-payload) *( lrxml-boundary lrxml-payload
                                      / lrxml-comment )

  lrxml-boundary  = "<!" CNS ":" NSNAME lrxml-attlist ">" EOL

  lrxml-comment   = "<!--#" CNS *comment-payload "-->"

  lrxml-payload   = ¬("<!" (CNS ":" / "#" CNS))

  lrxml-attlist   = *(1*WS / decl-comment / decl-macro / att-pair)

  decl-comment    = "--" comment-payload "--"

  comment-payload = *([^-] / "-" [^-])

  decl-macro      = "%" NAME *[0-9A-Za-z_:\.\-=\[\]\{\}\(,\)] ";"

  att-pair        = ?(NSNAME "=") att-value

  att-value       = squoted-att / dquoted-att / nested-att

  squoted-att     = ['] *[^'] [']

  dquoted-att     = ["] *[^"] ["]

  nested-att      = '[' lrxml-attlist ']'

  NSNAME          = NAME *(":" NAME)

  NAME            = 1*[0-9A-Za-z_]

  WS              = [\ \t\n]

  EOL             = ?[\r] [\n]


(Actually, in current YATT::Lite, C<NAME> can cotain C<\w> in perl unicode semantics.)

=head3 BNF of LRXML template syntax
X<LRXML-template>.

  lrxml-template   = ?(template-payload) *( (lrxml-entref / template-tag)
                                           ?(template-payload) )

  template-payload = ¬("<" (CNS ":" / "?" CNS))

  template-tag     = element / pi

  element          = "<" (single-elem / open-tag / close-tag) ">"

  pi               = "<?" CNS ?NSNAME pi-payload "?>"

  single-elem      = CNS NSNAME lrxml-attlist ?"/"

  open-tag         = CNS NSNAME lrxml-attlist

  close-tag        =  "/" CNS NSNAME

  pi-payload       = *([^?] / "?" [^>])

=head3 BNF of LRXML entity reference syntax
X<LRXML-entity-reference> X<LRXML-entref>

  lrxml-entref     = "&" (CNS (pipeline / lcmsg)
                         / special-entity "(" <group ")">)
                     ";"
  pipeline         = 1*( ":" NAME ?( "(" <group ")">)
                       / "[" <group "]">
                       / "{" <group "}">
                       )

  group C          = ent-term C

  ent-term         =

  lcmsg            =

  special-entity   = SPECIAL

I<Special entity> is another customizable syntax element.
For example, it is usually defined like:

  SPECIAL          = ("HTML")

And then you can write C<&HTML(:var);>.

But every implementation of LRXML parser should allow overriding this rule like
following instead:

  SPECIAL          = ("HTML" / "JSON" / "DUMP")

=head1 AUTHOR

"KOBAYASI, Hiroaki" <hkoba@cpan.org>

=head1 LICENSE

This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
