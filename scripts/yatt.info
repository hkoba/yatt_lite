#!/usr/bin/env perl
# -*- coding: utf-8 -*-
#----------------------------------------
use strict;
use warnings qw(FATAL all NONFATAL misc);
use FindBin; BEGIN {do "$FindBin::RealBin/libdir.pl"}
#----------------------------------------

use mro 'c3'; # XXX: Not fully compatible.
use parent qw/YATT::Lite::Object/;
use YATT::Lite::MFields qw/dispatcher
                           cf_dir
			   cf_linear
                           cf_from
                          /;

use YATT::Lite::Util qw/globref look_for_globref lexpand/;
use YATT::Lite::Util::CmdLine qw/run/;


use YATT::Lite;
use YATT::Lite::Factory;
use YATT::Lite::LRXML;
use YATT::Lite::Core;
use YATT::Lite::CGen::Perl;

{
  my $disp = YATT::Lite::Factory->load_factory_offline
    or die "Can't find YATT app script!\n";

  my MY $cmd = MY->new;
  $cmd->{dispatcher} = $disp;

  $cmd->run(\@ARGV);
}

sub cmd_isa {
  (my MY $self, my (@path)) = @_;

  my $disp = $self->{dispatcher};

  if (not @path) {
    $self->show_isa(dispatcher => ref $disp);
  } else {
    foreach my $path (@path) {
      my ($dir, $file) = do {
	if (-d $path) {
	  ($path)
	} else {
	  (dirname($path), basename($path));
	}
      };
      my $dh = $disp->get_dirhandler($dir);

      if (defined $file) {
	my ($part, $sub, $pkg) = $dh->open_trans->find_part_handler($file);
	$self->show_isa(File => $pkg);
	#      my ($tmpl) = $dh->open_trans->find_file($file);
	#      $self->show_isa(File => $tmpl->cget('entns'));
      } else {
	$self->show_isa(DirApp => ref $dh);
      }
    }
  }
}

sub show_isa {
  (my MY $self, my ($title, $class)) = @_;
  if ($self->{cf_linear}) {
    print "$title=$class\n";
    foreach my $super (@{mro::get_linear_isa($class)}) {
      my $fn = $self->get_class_filename($super);
      print "  ", $super, "\t", $fn ? "[$fn]" : "", "\n";
    }
  } else {
    print $class;
    if (my $fn = $self->get_class_filename($class)) {
      print "\t[$fn]";
    }
    print "\n";
    $self->show_isa_tree(0, {}, *{globref($class, 'ISA')}{ARRAY});
  }
}

sub show_isa_tree {
  (my MY $self, my ($depth, $seen, $supers)) = @_;
  $depth++;
  foreach my $super (@$supers) {
    my $cnt = $seen->{$super}++;
    print "  " x $depth, $cnt ? "*" : " ", $super;
    if (my $fn = $self->get_class_filename($super)) {
      print "\t[$fn]";
    }
    print "\n";
    next if $cnt;
    my $sym = look_for_globref($super, 'ISA')
      or next;
    my $isa = *{$sym}{ARRAY}
      or next;
    $self->show_isa_tree($depth, $seen, $isa);
  }
}

sub get_class_filename {
  (my MY $self, my ($cls, $default)) = @_;
  my $fnsym = look_for_globref($cls, 'filename')
    or return $default;
  my $sub = *{$fnsym}{CODE}
    or return $default;
  $sub->() // $default;
}

sub is_in_template_dir {
  (my MY $self, my $path) = @_;
  foreach my $dir (lexpand($self->{dispatcher}->{tmpldirs})) {
    if (length $dir <= length $path
        and substr($dir, 0, length $path) eq $path) {
      return 1;
    }
  }
  return 0;
}

sub cmd_list_widgets {
  (my MY $self, my ($widgetNameGlob, $argPat)) = @_;

  my $cwdOrFile = $self->{cf_from}
    ? $self->rel2abs($self->{cf_from})
    : do {
    my $cwd = Cwd::getcwd;
    if ($self->is_in_template_dir($cwd)) {
      $cwd;
    } else {
      $self->{dispatcher}->cget('doc_root') // do {
        if ($self->{dispatcher}->cget('per_role_docroot')) {
          die "Currently, list_widgets can't handle per_role_docroot, sorry.\n";
        }
      };
    }
  };

  my ($dir, $rootName) = do {
    if (-d $cwdOrFile) {
      ($cwdOrFile, '');
    } else {
      my ($fn, $dn, $ext) = File::Basename::fileparse($cwdOrFile, qr{\.\w+\z});
      ($dn, $fn, $ext);
    }
  };

  my $yatt = $self->{dispatcher}->load_yatt($dir);
  my $vfs = $yatt->get_trans;

  my $rootPart = $rootName
    ? $vfs->find_file($rootName)
    : $vfs->{root};

  {
    my %seen;
    my $traverse;
    $traverse = sub {
      my ($tree, $widgetNamePat, $prefix) = @_;
      if ($tree->can_generate_code) {
        # Template
        $seen{$tree->{cf_path}}++;
        foreach my $part ($tree->list_parts) {
          my $partName = $part->cget('name');
          my @path = (@{$prefix // []}, $partName || ());
          next unless @path;
          my $wname = join(":", @path);
          if ($widgetNamePat and $wname !~ $widgetNamePat) {
            next;
          }
          print ":", $wname, "\n";
        }
      } else {
        # Dir
        foreach my $itemName ($tree->list_all_names($vfs)) {
          my $subtree = $tree->lookup_1($vfs, $itemName);
          next if $seen{$subtree->{cf_path}}++;
          print "# $subtree->{cf_path}\n";
          $traverse->($subtree, $widgetNamePat, [@{$prefix // []}, $itemName]);
        }
        # これだと subdir が出ない。
      }
      foreach my $superItem ($tree->list_base) {
        $traverse->($superItem, $widgetNamePat);
      }
    };

    use Text::Glob;
    my $re;
    $re = Text::Glob::glob_to_regex($widgetNameGlob) if $widgetNameGlob;
    $traverse->($rootPart, $re);
  }
  # $yatt->get_trans->list_items
  # $yatt->get_trans->find_file('index')
  # $yatt->get_trans->find_file('index')->list_parts
}
